{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n// Bundled with Packemon: https://packemon.dev\n// Platform: browser, Support: stable, Format: esm\nimport { F as Filter, A as ALLOWED_TAG_LIST, B as BANNED_TAG_LIST, a as ATTRIBUTES, b as FILTER_DENY, c as ATTRIBUTES_TO_PROPS, T as TAGS, E as Element, d as FILTER_CAST_BOOL, e as FILTER_CAST_NUMBER, f as FILTER_NO_CAST } from './bundle-7aab7250.js';\nexport { A as ALLOWED_TAG_LIST, a as ATTRIBUTES, c as ATTRIBUTES_TO_PROPS, B as BANNED_TAG_LIST, E as Element, n as FILTER_ALLOW, d as FILTER_CAST_BOOL, e as FILTER_CAST_NUMBER, b as FILTER_DENY, f as FILTER_NO_CAST, F as Filter, M as Matcher, T as TAGS, k as TYPE_EMBEDDED, g as TYPE_FLOW, i as TYPE_HEADING, l as TYPE_INTERACTIVE, m as TYPE_PALPABLE, j as TYPE_PHRASING, h as TYPE_SECTION, o as match } from './bundle-7aab7250.js';\nimport React from 'react';\nimport escapeHtml from 'escape-html';\nconst INVALID_STYLES = /(url|image|image-set)\\(/i;\nclass StyleFilter extends Filter {\n  attribute(name, value) {\n    if (name === 'style') {\n      Object.keys(value).forEach(key => {\n        if (String(value[key]).match(INVALID_STYLES)) {\n          // eslint-disable-next-line no-param-reassign\n          delete value[key];\n        }\n      });\n    } // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n\n    return value;\n  }\n}\n/* eslint-disable no-bitwise, no-cond-assign, complexity, @typescript-eslint/no-unsafe-return */\n\nconst ELEMENT_NODE = 1;\nconst TEXT_NODE = 3;\nconst INVALID_ROOTS = /^<(!doctype|(html|head|body)(\\s|>))/i;\nconst ALLOWED_ATTRS = /^(aria-|data-|\\w+:)/iu;\nconst OPEN_TOKEN = /{{{(\\w+)\\/?}}}/;\nfunction createDocument() {\n  // Maybe SSR? Just do nothing instead of crashing!\n  if (typeof window === 'undefined' || typeof document === 'undefined') {\n    return undefined;\n  }\n  return document.implementation.createHTMLDocument('Interweave');\n}\nclass Parser {\n  constructor(markup, props = {}, matchers = [], filters = []) {\n    var _props$allowList;\n    _defineProperty(this, \"allowed\", void 0);\n    _defineProperty(this, \"banned\", void 0);\n    _defineProperty(this, \"blocked\", void 0);\n    _defineProperty(this, \"container\", void 0);\n    _defineProperty(this, \"content\", []);\n    _defineProperty(this, \"props\", void 0);\n    _defineProperty(this, \"matchers\", void 0);\n    _defineProperty(this, \"filters\", void 0);\n    _defineProperty(this, \"keyIndex\", void 0);\n    if (process.env.NODE_ENV !== \"production\" && markup && typeof markup !== 'string') {\n      throw new TypeError('Interweave parser requires a valid string.');\n    }\n    this.props = props;\n    this.matchers = matchers;\n    this.filters = [...filters, new StyleFilter()];\n    this.keyIndex = -1;\n    this.container = this.createContainer(markup || '');\n    this.allowed = new Set((_props$allowList = props.allowList) !== null && _props$allowList !== void 0 ? _props$allowList : ALLOWED_TAG_LIST);\n    this.banned = new Set(BANNED_TAG_LIST);\n    this.blocked = new Set(props.blockList);\n  }\n  /**\n   * Loop through and apply all registered attribute filters.\n   */\n\n  applyAttributeFilters(name, value) {\n    return this.filters.reduce((nextValue, filter) => nextValue !== null && typeof filter.attribute === 'function' ? filter.attribute(name, nextValue) : nextValue, value);\n  }\n  /**\n   * Loop through and apply all registered node filters.\n   */\n\n  applyNodeFilters(name, node) {\n    // Allow null to be returned\n    return this.filters.reduce((nextNode, filter) => nextNode !== null && typeof filter.node === 'function' ? filter.node(name, nextNode) : nextNode, node);\n  }\n  /**\n   * Loop through and apply all registered matchers to the string.\n   * If a match is found, create a React element, and build a new array.\n   * This array allows React to interpolate and render accordingly.\n   */\n\n  applyMatchers(string, parentConfig) {\n    const elements = {};\n    const {\n      props\n    } = this;\n    let matchedString = string;\n    let elementIndex = 0;\n    let parts = null;\n    this.matchers.forEach(matcher => {\n      const tagName = matcher.asTag().toLowerCase();\n      const config = this.getTagConfig(tagName); // Skip matchers that have been disabled from props or are not supported\n\n      if (props[matcher.inverseName] || !this.isTagAllowed(tagName)) {\n        return;\n      } // Skip matchers in which the child cannot be rendered\n\n      if (!this.canRenderChild(parentConfig, config)) {\n        return;\n      } // Continuously trigger the matcher until no matches are found\n\n      let tokenizedString = '';\n      while (matchedString && (parts = matcher.match(matchedString))) {\n        const {\n          index,\n          length,\n          match,\n          valid,\n          void: isVoid,\n          ...partProps\n        } = parts;\n        const tokenName = matcher.propName + String(elementIndex); // Piece together a new string with interpolated tokens\n\n        if (index > 0) {\n          tokenizedString += matchedString.slice(0, index);\n        }\n        if (valid) {\n          tokenizedString += isVoid ? `{{{${tokenName}/}}}` : `{{{${tokenName}}}}${match}{{{/${tokenName}}}}`;\n          this.keyIndex += 1;\n          elementIndex += 1;\n          elements[tokenName] = {\n            children: match,\n            matcher,\n            props: {\n              ...props,\n              ...partProps,\n              key: this.keyIndex\n            }\n          };\n        } else {\n          tokenizedString += match;\n        } // Reduce the string being matched against,\n        // otherwise we end up in an infinite loop!\n\n        if (matcher.greedy) {\n          matchedString = tokenizedString + matchedString.slice(index + length);\n          tokenizedString = '';\n        } else {\n          // eslint-disable-next-line unicorn/explicit-length-check\n          matchedString = matchedString.slice(index + (length || match.length));\n        }\n      } // Update the matched string with the tokenized string,\n      // so that the next matcher can apply to it.\n\n      if (!matcher.greedy) {\n        matchedString = tokenizedString + matchedString;\n      }\n    });\n    if (elementIndex === 0) {\n      return string;\n    }\n    return this.replaceTokens(matchedString, elements);\n  }\n  /**\n   * Determine whether the child can be rendered within the parent.\n   */\n\n  canRenderChild(parentConfig, childConfig) {\n    if (!parentConfig.tagName || !childConfig.tagName) {\n      return false;\n    } // No children\n\n    if (parentConfig.void) {\n      return false;\n    } // Valid children\n\n    if (parentConfig.children.length > 0) {\n      return parentConfig.children.includes(childConfig.tagName);\n    }\n    if (parentConfig.invalid.length > 0 && parentConfig.invalid.includes(childConfig.tagName)) {\n      return false;\n    } // Valid parent\n\n    if (childConfig.parent.length > 0) {\n      return childConfig.parent.includes(parentConfig.tagName);\n    } // Self nesting\n\n    if (!parentConfig.self && parentConfig.tagName === childConfig.tagName) {\n      return false;\n    } // Content category type\n\n    return Boolean(parentConfig && parentConfig.content & childConfig.type);\n  }\n  /**\n   * Convert line breaks in a string to HTML `<br/>` tags.\n   * If the string contains HTML, we should not convert anything,\n   * as line breaks should be handled by `<br/>`s in the markup itself.\n   */\n\n  convertLineBreaks(markup) {\n    const {\n      noHtml,\n      disableLineBreaks\n    } = this.props;\n    if (noHtml || disableLineBreaks || markup.match(/<((?:\\/[ a-z]+)|(?:[ a-z]+\\/))>/gi)) {\n      return markup;\n    } // Replace carriage returns\n\n    let nextMarkup = markup.replace(/\\r\\n/g, '\\n'); // Replace long line feeds\n\n    nextMarkup = nextMarkup.replace(/\\n{3,}/g, '\\n\\n\\n'); // Replace line feeds with `<br/>`s\n\n    nextMarkup = nextMarkup.replace(/\\n/g, '<br/>');\n    return nextMarkup;\n  }\n  /**\n   * Create a detached HTML document that allows for easy HTML\n   * parsing while not triggering scripts or loading external\n   * resources.\n   */\n\n  createContainer(markup) {\n    var _this$props$container;\n    const factory = typeof global !== 'undefined' && global.INTERWEAVE_SSR_POLYFILL || createDocument;\n    const doc = factory();\n    if (!doc) {\n      return undefined;\n    }\n    const tag = (_this$props$container = this.props.containerTagName) !== null && _this$props$container !== void 0 ? _this$props$container : 'body';\n    const el = tag === 'body' || tag === 'fragment' ? doc.body : doc.createElement(tag);\n    if (markup.match(INVALID_ROOTS)) {\n      if (process.env.NODE_ENV !== \"production\") {\n        throw new Error('HTML documents as Interweave content are not supported.');\n      }\n    } else {\n      el.innerHTML = this.convertLineBreaks(this.props.escapeHtml ? escapeHtml(markup) : markup);\n    }\n    return el;\n  }\n  /**\n   * Convert an elements attribute map to an object map.\n   * Returns null if no attributes are defined.\n   */\n\n  extractAttributes(node) {\n    const {\n      allowAttributes\n    } = this.props;\n    const attributes = {};\n    let count = 0;\n    if (node.nodeType !== ELEMENT_NODE || !node.attributes) {\n      return null;\n    } // @ts-expect-error Cant type iterator\n\n    [...node.attributes].forEach(attr => {\n      const {\n        name,\n        value\n      } = attr;\n      const newName = name.toLowerCase();\n      const filter = ATTRIBUTES[newName] || ATTRIBUTES[name]; // Verify the node is safe from attacks\n\n      if (!this.isSafe(node)) {\n        return;\n      } // Do not allow denied attributes, excluding ARIA attributes\n      // Do not allow events or XSS injections\n\n      if (!newName.match(ALLOWED_ATTRS) && (!allowAttributes && (!filter || filter === FILTER_DENY) || newName.startsWith('on') || value.replace(/(\\s|\\0|&#x0([9AD]);)/, '').match(/(javascript|vbscript|livescript|xss):/i))) {\n        return;\n      } // Apply attribute filters\n\n      let newValue = newName === 'style' ? this.extractStyleAttribute(node) : value; // Cast to boolean\n\n      if (filter === FILTER_CAST_BOOL) {\n        newValue = true; // Cast to number\n      } else if (filter === FILTER_CAST_NUMBER) {\n        newValue = Number.parseFloat(String(newValue)); // Cast to string\n      } else if (filter !== FILTER_NO_CAST) {\n        newValue = String(newValue);\n      }\n      attributes[ATTRIBUTES_TO_PROPS[newName] || newName] = this.applyAttributeFilters(newName, newValue);\n      count += 1;\n    });\n    if (count === 0) {\n      return null;\n    }\n    return attributes;\n  }\n  /**\n   * Extract the style attribute as an object and remove values that allow for attack vectors.\n   */\n\n  extractStyleAttribute(node) {\n    const styles = {}; // eslint-disable-next-line unicorn/prefer-spread\n\n    Array.from(node.style).forEach(key => {\n      const value = node.style[key];\n      if (typeof value === 'string' || typeof value === 'number') {\n        styles[key.replace(/-([a-z])/g, (match, letter) => String(letter).toUpperCase())] = value;\n      }\n    });\n    return styles;\n  }\n  /**\n   * Return configuration for a specific tag.\n   */\n\n  getTagConfig(tagName) {\n    const common = {\n      children: [],\n      content: 0,\n      invalid: [],\n      parent: [],\n      self: true,\n      tagName: '',\n      type: 0,\n      void: false\n    }; // Only spread when a tag config exists,\n    // otherwise we use the empty `tagName`\n    // for parent config inheritance.\n\n    if (TAGS[tagName]) {\n      return {\n        ...common,\n        ...TAGS[tagName],\n        tagName\n      };\n    }\n    return common;\n  }\n  /**\n   * Verify that a node is safe from XSS and injection attacks.\n   */\n\n  isSafe(node) {\n    // URLs should only support HTTP, email and phone numbers\n    if (typeof HTMLAnchorElement !== 'undefined' && node instanceof HTMLAnchorElement) {\n      const href = node.getAttribute('href'); // Fragment protocols start with about:\n      // So let's just allow them\n\n      if (href !== null && href !== void 0 && href.startsWith('#')) {\n        return true;\n      }\n      const protocol = node.protocol.toLowerCase();\n      return protocol === ':' || protocol === 'http:' || protocol === 'https:' || protocol === 'mailto:' || protocol === 'tel:';\n    }\n    return true;\n  }\n  /**\n   * Verify that an HTML tag is allowed to render.\n   */\n\n  isTagAllowed(tagName) {\n    if (this.banned.has(tagName) || this.blocked.has(tagName)) {\n      return false;\n    } // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n\n    return this.props.allowElements || this.allowed.has(tagName);\n  }\n  /**\n   * Parse the markup by injecting it into a detached document,\n   * while looping over all child nodes and generating an\n   * array to interpolate into JSX.\n   */\n\n  parse() {\n    if (!this.container) {\n      return [];\n    }\n    return this.parseNode(this.container, this.getTagConfig(this.container.nodeName.toLowerCase()));\n  }\n  /**\n   * Loop over the nodes children and generate a\n   * list of text nodes and React elements.\n   */\n\n  parseNode(parentNode, parentConfig) {\n    const {\n      noHtml,\n      noHtmlExceptMatchers,\n      allowElements,\n      transform,\n      transformOnlyAllowList\n    } = this.props;\n    let content = [];\n    let mergedText = ''; // @ts-expect-error Cant type iterator\n\n    [...parentNode.childNodes].forEach(node => {\n      // Create React elements from HTML elements\n      if (node.nodeType === ELEMENT_NODE) {\n        const tagName = node.nodeName.toLowerCase();\n        const config = this.getTagConfig(tagName); // Persist any previous text\n\n        if (mergedText) {\n          content.push(mergedText);\n          mergedText = '';\n        } // Apply node filters first\n\n        const nextNode = this.applyNodeFilters(tagName, node);\n        if (!nextNode) {\n          return;\n        } // Apply transformation second\n\n        let children;\n        if (transform && !(transformOnlyAllowList && !this.isTagAllowed(tagName))) {\n          this.keyIndex += 1;\n          const key = this.keyIndex; // Must occur after key is set\n\n          children = this.parseNode(nextNode, config);\n          const transformed = transform(nextNode, children, config);\n          if (transformed === null) {\n            return;\n          }\n          if (typeof transformed !== 'undefined') {\n            content.push( /*#__PURE__*/React.cloneElement(transformed, {\n              key\n            }));\n            return;\n          } // Reset as we're not using the transformation\n\n          this.keyIndex = key - 1;\n        } // Never allow these tags (except via a transformer)\n\n        if (this.banned.has(tagName)) {\n          return;\n        } // Only render when the following criteria is met:\n        //  - HTML has not been disabled\n        //  - Tag is allowed\n        //  - Child is valid within the parent\n\n        if (!(noHtml || noHtmlExceptMatchers && tagName !== 'br') && this.isTagAllowed(tagName) && (allowElements || this.canRenderChild(parentConfig, config))) {\n          var _children;\n          this.keyIndex += 1; // Build the props as it makes it easier to test\n\n          const attributes = this.extractAttributes(nextNode);\n          const elementProps = {\n            tagName\n          };\n          if (attributes) {\n            elementProps.attributes = attributes;\n          }\n          if (config.void) {\n            elementProps.selfClose = config.void;\n          }\n          content.push( /*#__PURE__*/React.createElement(Element, {\n            ...elementProps,\n            key: this.keyIndex\n          }, (_children = children) !== null && _children !== void 0 ? _children : this.parseNode(nextNode, config))); // Render the children of the current element only.\n          // Important: If the current element is not allowed,\n          // use the parent element for the next scope.\n        } else {\n          content = [...content, ...this.parseNode(nextNode, config.tagName ? config : parentConfig)];\n        } // Apply matchers if a text node\n      } else if (node.nodeType === TEXT_NODE) {\n        const text = noHtml && !noHtmlExceptMatchers ? node.textContent :\n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        this.applyMatchers(node.textContent || '', parentConfig);\n        if (Array.isArray(text)) {\n          content = [...content, ...text];\n        } else {\n          mergedText += text;\n        }\n      }\n    });\n    if (mergedText) {\n      content.push(mergedText);\n    }\n    return content;\n  }\n  /**\n   * Deconstruct the string into an array, by replacing custom tokens with React elements,\n   * so that React can render it correctly.\n   */\n\n  replaceTokens(tokenizedString, elements) {\n    if (!tokenizedString.includes('{{{')) {\n      return tokenizedString;\n    }\n    const nodes = [];\n    let text = tokenizedString;\n    let open = null; // Find an open token tag\n\n    while (open = text.match(OPEN_TOKEN)) {\n      const [match, tokenName] = open;\n      const startIndex = open.index;\n      const isVoid = match.includes('/');\n      if (process.env.NODE_ENV !== \"production\" && !elements[tokenName]) {\n        throw new Error(`Token \"${tokenName}\" found but no matching element to replace with.`);\n      } // Extract the previous non-token text\n\n      if (startIndex > 0) {\n        nodes.push(text.slice(0, startIndex)); // Reduce text so that the closing tag will be found after the opening\n\n        text = text.slice(startIndex);\n      }\n      const {\n        children,\n        matcher,\n        props: elementProps\n      } = elements[tokenName];\n      let endIndex; // Use tag as-is if void\n\n      if (isVoid) {\n        endIndex = match.length;\n        nodes.push(matcher.createElement(children, elementProps)); // Find the closing tag if not void\n      } else {\n        const close = text.match(new RegExp(`{{{/${tokenName}}}}`));\n        if (process.env.NODE_ENV !== \"production\" && !close) {\n          throw new Error(`Closing token missing for interpolated element \"${tokenName}\".`);\n        }\n        endIndex = close.index + close[0].length;\n        nodes.push(matcher.createElement(this.replaceTokens(text.slice(match.length, close.index), elements), elementProps));\n      } // Reduce text for the next interation\n\n      text = text.slice(endIndex);\n    } // Extra the remaining text\n\n    if (text.length > 0) {\n      nodes.push(text);\n    } // Reduce to a string if possible\n\n    if (nodes.length === 0) {\n      return '';\n    }\n    if (nodes.length === 1 && typeof nodes[0] === 'string') {\n      return nodes[0];\n    }\n    return nodes;\n  }\n}\n/* eslint-disable react/jsx-fragments */\n\nfunction Markup(props) {\n  var _ref;\n  const {\n    attributes,\n    className,\n    containerTagName,\n    content,\n    emptyContent,\n    parsedContent,\n    tagName,\n    noWrap: baseNoWrap\n  } = props;\n  const tag = (_ref = containerTagName !== null && containerTagName !== void 0 ? containerTagName : tagName) !== null && _ref !== void 0 ? _ref : 'span';\n  const noWrap = tag === 'fragment' ? true : baseNoWrap;\n  let mainContent;\n  if (parsedContent) {\n    mainContent = parsedContent;\n  } else {\n    const markup = new Parser(content !== null && content !== void 0 ? content : '', props).parse();\n    if (markup.length > 0) {\n      mainContent = markup;\n    }\n  }\n  if (!mainContent) {\n    mainContent = emptyContent;\n  }\n  if (noWrap) {\n    // eslint-disable-next-line react/jsx-no-useless-fragment\n    return /*#__PURE__*/React.createElement(React.Fragment, null, mainContent);\n  }\n  return /*#__PURE__*/React.createElement(Element, {\n    attributes: attributes,\n    className: className,\n    tagName: tag\n  }, mainContent);\n}\n/* eslint-disable promise/prefer-await-to-callbacks */\n\nfunction Interweave(props) {\n  const {\n    attributes,\n    className,\n    content = '',\n    disableFilters = false,\n    disableMatchers = false,\n    emptyContent = null,\n    filters = [],\n    matchers = [],\n    onAfterParse = null,\n    onBeforeParse = null,\n    tagName = 'span',\n    noWrap = false,\n    ...parserProps\n  } = props;\n  const allMatchers = disableMatchers ? [] : matchers;\n  const allFilters = disableFilters ? [] : filters;\n  const beforeCallbacks = onBeforeParse ? [onBeforeParse] : [];\n  const afterCallbacks = onAfterParse ? [onAfterParse] : []; // Inherit callbacks from matchers\n\n  allMatchers.forEach(matcher => {\n    if (matcher.onBeforeParse) {\n      beforeCallbacks.push(matcher.onBeforeParse.bind(matcher));\n    }\n    if (matcher.onAfterParse) {\n      afterCallbacks.push(matcher.onAfterParse.bind(matcher));\n    }\n  }); // Trigger before callbacks\n\n  const markup = beforeCallbacks.reduce((string, callback) => {\n    const nextString = callback(string, props);\n    if (process.env.NODE_ENV !== \"production\" && typeof nextString !== 'string') {\n      throw new TypeError('Interweave `onBeforeParse` must return a valid HTML string.');\n    }\n    return nextString;\n  }, content !== null && content !== void 0 ? content : ''); // Parse the markup\n\n  const parser = new Parser(markup, parserProps, allMatchers, allFilters); // Trigger after callbacks\n\n  const nodes = afterCallbacks.reduce((parserNodes, callback) => {\n    const nextNodes = callback(parserNodes, props);\n    if (process.env.NODE_ENV !== \"production\" && !Array.isArray(nextNodes)) {\n      throw new TypeError('Interweave `onAfterParse` must return an array of strings and React elements.');\n    }\n    return nextNodes;\n  }, parser.parse());\n  return /*#__PURE__*/React.createElement(Markup, {\n    attributes: attributes,\n    className: className // eslint-disable-next-line react/destructuring-assignment\n    ,\n\n    containerTagName: props.containerTagName,\n    emptyContent: emptyContent,\n    noWrap: noWrap,\n    parsedContent: nodes.length === 0 ? undefined : nodes,\n    tagName: tagName\n  });\n}\nexport { Interweave, Markup, Parser };","map":{"version":3,"names":["StyleFilter","Filter","attribute","name","value","Object","keys","forEach","key","String","match","INVALID_STYLES","ELEMENT_NODE","TEXT_NODE","INVALID_ROOTS","ALLOWED_ATTRS","createDocument","window","document","undefined","implementation","createHTMLDocument","Parser","constructor","banned","markup","props","matchers","filters","_props$allowList","_defineProperty","process","env","NODE_ENV","TypeError","keyIndex","container","createContainer","allowed","Set","allowList","ALLOWED_TAG_LIST","BANNED_TAG_LIST","blocked","blockList","applyAttributeFilters","reduce","nextValue","filter","applyNodeFilters","node","nextNode","elements","elementIndex","parts","matcher","canRenderChild","parentConfig","config","tokenizedString","matchedString","index","valid","void","isVoid","partProps","tokenName","propName","slice","greedy","length","string","childConfig","tagName","children","invalid","includes","parent","self","Boolean","content","type","convertLineBreaks","noHtml","disableLineBreaks","nextMarkup","replace","_this$props$container","factory","global","INTERWEAVE_SSR_POLYFILL","doc","tag","containerTagName","el","body","createElement","innerHTML","escapeHtml","extractAttributes","allowAttributes","attributes","count","nodeType","ATTRIBUTES","newName","isSafe","FILTER_DENY","startsWith","FILTER_CAST_BOOL","newValue","Number","parseFloat","FILTER_NO_CAST","extractStyleAttribute","styles","style","letter","toUpperCase","common","TAGS","HTMLAnchorElement","href","getAttribute","protocol","toLowerCase","parse","parseNode","getTagConfig","nodeName","parentNode","allowElements","transform","transformOnlyAllowList","mergedText","isTagAllowed","transformed","push","React","cloneElement","has","noHtmlExceptMatchers","_children","elementProps","Element","text","textContent","applyMatchers","Array","isArray","replaceTokens","nodes","open","startIndex","Error","endIndex","close","RegExp","Markup","mainContent","_ref","className","parsedContent","noWrap","baseNoWrap","emptyContent","Fragment","Interweave","disableFilters","onAfterParse","allMatchers","disableMatchers","allFilters","afterCallbacks","onBeforeParse","bind","beforeCallbacks","callback","nextString","parser","parserProps","parserNodes"],"sources":["/var/www/html/i2pay-portal/node_modules/interweave/src/StyleFilter.ts","/var/www/html/i2pay-portal/node_modules/interweave/src/Parser.ts","/var/www/html/i2pay-portal/node_modules/interweave/src/Markup.tsx","/var/www/html/i2pay-portal/node_modules/interweave/src/Interweave.tsx"],"sourcesContent":["import { Filter } from './Filter';\nimport { ElementAttributes } from './types';\n\nconst INVALID_STYLES = /(url|image|image-set)\\(/i;\n\nexport class StyleFilter extends Filter {\n\toverride attribute<K extends keyof ElementAttributes>(\n\t\tname: K,\n\t\tvalue: ElementAttributes[K],\n\t): ElementAttributes[K] {\n\t\tif (name === 'style') {\n\t\t\tObject.keys(value).forEach((key) => {\n\t\t\t\tif (String(value[key]).match(INVALID_STYLES)) {\n\t\t\t\t\t// eslint-disable-next-line no-param-reassign\n\t\t\t\t\tdelete value[key];\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-return\n\t\treturn value;\n\t}\n}\n","/* eslint-disable no-bitwise, no-cond-assign, complexity, @typescript-eslint/no-unsafe-return */\n\nimport React from 'react';\nimport escapeHtml from 'escape-html';\nimport {\n\tALLOWED_TAG_LIST,\n\tATTRIBUTES,\n\tATTRIBUTES_TO_PROPS,\n\tBANNED_TAG_LIST,\n\tFILTER_CAST_BOOL,\n\tFILTER_CAST_NUMBER,\n\tFILTER_DENY,\n\tFILTER_NO_CAST,\n\tTAGS,\n} from './constants';\nimport { Element } from './Element';\nimport { StyleFilter } from './StyleFilter';\nimport {\n\tAttributes,\n\tAttributeValue,\n\tChildrenNode,\n\tElementAttributes,\n\tElementProps,\n\tFilterInterface,\n\tMatcherElementsMap,\n\tMatcherInterface,\n\tNode,\n\tNodeConfig,\n\tParserProps,\n} from './types';\n\nconst ELEMENT_NODE = 1;\nconst TEXT_NODE = 3;\nconst INVALID_ROOTS = /^<(!doctype|(html|head|body)(\\s|>))/i;\nconst ALLOWED_ATTRS = /^(aria-|data-|\\w+:)/iu;\nconst OPEN_TOKEN = /{{{(\\w+)\\/?}}}/;\n\nfunction createDocument() {\n\t// Maybe SSR? Just do nothing instead of crashing!\n\tif (typeof window === 'undefined' || typeof document === 'undefined') {\n\t\treturn undefined;\n\t}\n\n\treturn document.implementation.createHTMLDocument('Interweave');\n}\n\nexport class Parser {\n\tallowed: Set<string>;\n\n\tbanned: Set<string>;\n\n\tblocked: Set<string>;\n\n\tcontainer?: HTMLElement;\n\n\tcontent: Node[] = [];\n\n\tprops: ParserProps;\n\n\tmatchers: MatcherInterface[];\n\n\tfilters: FilterInterface[];\n\n\tkeyIndex: number;\n\n\tconstructor(\n\t\tmarkup: string,\n\t\tprops: ParserProps = {},\n\t\tmatchers: MatcherInterface[] = [],\n\t\tfilters: FilterInterface[] = [],\n\t) {\n\t\tif (__DEV__ && markup && typeof markup !== 'string') {\n\t\t\tthrow new TypeError('Interweave parser requires a valid string.');\n\t\t}\n\n\t\tthis.props = props;\n\t\tthis.matchers = matchers;\n\t\tthis.filters = [...filters, new StyleFilter()];\n\t\tthis.keyIndex = -1;\n\t\tthis.container = this.createContainer(markup || '');\n\t\tthis.allowed = new Set(props.allowList ?? ALLOWED_TAG_LIST);\n\t\tthis.banned = new Set(BANNED_TAG_LIST);\n\t\tthis.blocked = new Set(props.blockList);\n\t}\n\n\t/**\n\t * Loop through and apply all registered attribute filters.\n\t */\n\tapplyAttributeFilters<K extends keyof ElementAttributes>(\n\t\tname: K,\n\t\tvalue: ElementAttributes[K],\n\t): ElementAttributes[K] {\n\t\treturn this.filters.reduce(\n\t\t\t(nextValue, filter) =>\n\t\t\t\tnextValue !== null && typeof filter.attribute === 'function'\n\t\t\t\t\t? filter.attribute(name, nextValue)\n\t\t\t\t\t: nextValue,\n\t\t\tvalue,\n\t\t);\n\t}\n\n\t/**\n\t * Loop through and apply all registered node filters.\n\t */\n\tapplyNodeFilters(name: string, node: HTMLElement | null): HTMLElement | null {\n\t\t// Allow null to be returned\n\t\treturn this.filters.reduce(\n\t\t\t(nextNode, filter) =>\n\t\t\t\tnextNode !== null && typeof filter.node === 'function'\n\t\t\t\t\t? filter.node(name, nextNode)\n\t\t\t\t\t: nextNode,\n\t\t\tnode,\n\t\t);\n\t}\n\n\t/**\n\t * Loop through and apply all registered matchers to the string.\n\t * If a match is found, create a React element, and build a new array.\n\t * This array allows React to interpolate and render accordingly.\n\t */\n\tapplyMatchers(string: string, parentConfig: NodeConfig): ChildrenNode {\n\t\tconst elements: MatcherElementsMap = {};\n\t\tconst { props } = this;\n\t\tlet matchedString = string;\n\t\tlet elementIndex = 0;\n\t\tlet parts = null;\n\n\t\tthis.matchers.forEach((matcher) => {\n\t\t\tconst tagName = matcher.asTag().toLowerCase();\n\t\t\tconst config = this.getTagConfig(tagName);\n\n\t\t\t// Skip matchers that have been disabled from props or are not supported\n\t\t\tif ((props as Record<string, unknown>)[matcher.inverseName] || !this.isTagAllowed(tagName)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Skip matchers in which the child cannot be rendered\n\t\t\tif (!this.canRenderChild(parentConfig, config)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Continuously trigger the matcher until no matches are found\n\t\t\tlet tokenizedString = '';\n\n\t\t\twhile (matchedString && (parts = matcher.match(matchedString))) {\n\t\t\t\tconst { index, length, match, valid, void: isVoid, ...partProps } = parts;\n\t\t\t\tconst tokenName = matcher.propName + String(elementIndex);\n\n\t\t\t\t// Piece together a new string with interpolated tokens\n\t\t\t\tif (index > 0) {\n\t\t\t\t\ttokenizedString += matchedString.slice(0, index);\n\t\t\t\t}\n\n\t\t\t\tif (valid) {\n\t\t\t\t\ttokenizedString += isVoid\n\t\t\t\t\t\t? `{{{${tokenName}/}}}`\n\t\t\t\t\t\t: `{{{${tokenName}}}}${match}{{{/${tokenName}}}}`;\n\n\t\t\t\t\tthis.keyIndex += 1;\n\n\t\t\t\t\telementIndex += 1;\n\t\t\t\t\telements[tokenName] = {\n\t\t\t\t\t\tchildren: match,\n\t\t\t\t\t\tmatcher,\n\t\t\t\t\t\tprops: {\n\t\t\t\t\t\t\t...props,\n\t\t\t\t\t\t\t...partProps,\n\t\t\t\t\t\t\tkey: this.keyIndex,\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\ttokenizedString += match;\n\t\t\t\t}\n\n\t\t\t\t// Reduce the string being matched against,\n\t\t\t\t// otherwise we end up in an infinite loop!\n\t\t\t\tif (matcher.greedy) {\n\t\t\t\t\tmatchedString = tokenizedString + matchedString.slice(index + length);\n\t\t\t\t\ttokenizedString = '';\n\t\t\t\t} else {\n\t\t\t\t\t// eslint-disable-next-line unicorn/explicit-length-check\n\t\t\t\t\tmatchedString = matchedString.slice(index + (length || match.length));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update the matched string with the tokenized string,\n\t\t\t// so that the next matcher can apply to it.\n\t\t\tif (!matcher.greedy) {\n\t\t\t\tmatchedString = tokenizedString + matchedString;\n\t\t\t}\n\t\t});\n\n\t\tif (elementIndex === 0) {\n\t\t\treturn string;\n\t\t}\n\n\t\treturn this.replaceTokens(matchedString, elements);\n\t}\n\n\t/**\n\t * Determine whether the child can be rendered within the parent.\n\t */\n\tcanRenderChild(parentConfig: NodeConfig, childConfig: NodeConfig): boolean {\n\t\tif (!parentConfig.tagName || !childConfig.tagName) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// No children\n\t\tif (parentConfig.void) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Valid children\n\t\tif (parentConfig.children.length > 0) {\n\t\t\treturn parentConfig.children.includes(childConfig.tagName);\n\t\t}\n\n\t\tif (parentConfig.invalid.length > 0 && parentConfig.invalid.includes(childConfig.tagName)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Valid parent\n\t\tif (childConfig.parent.length > 0) {\n\t\t\treturn childConfig.parent.includes(parentConfig.tagName);\n\t\t}\n\n\t\t// Self nesting\n\t\tif (!parentConfig.self && parentConfig.tagName === childConfig.tagName) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Content category type\n\t\treturn Boolean(parentConfig && parentConfig.content & childConfig.type);\n\t}\n\n\t/**\n\t * Convert line breaks in a string to HTML `<br/>` tags.\n\t * If the string contains HTML, we should not convert anything,\n\t * as line breaks should be handled by `<br/>`s in the markup itself.\n\t */\n\tconvertLineBreaks(markup: string): string {\n\t\tconst { noHtml, disableLineBreaks } = this.props;\n\n\t\tif (noHtml || disableLineBreaks || markup.match(/<((?:\\/[ a-z]+)|(?:[ a-z]+\\/))>/gi)) {\n\t\t\treturn markup;\n\t\t}\n\n\t\t// Replace carriage returns\n\t\tlet nextMarkup = markup.replace(/\\r\\n/g, '\\n');\n\n\t\t// Replace long line feeds\n\t\tnextMarkup = nextMarkup.replace(/\\n{3,}/g, '\\n\\n\\n');\n\n\t\t// Replace line feeds with `<br/>`s\n\t\tnextMarkup = nextMarkup.replace(/\\n/g, '<br/>');\n\n\t\treturn nextMarkup;\n\t}\n\n\t/**\n\t * Create a detached HTML document that allows for easy HTML\n\t * parsing while not triggering scripts or loading external\n\t * resources.\n\t */\n\tcreateContainer(markup: string): HTMLElement | undefined {\n\t\tconst factory =\n\t\t\t(typeof global !== 'undefined' && global.INTERWEAVE_SSR_POLYFILL) || createDocument;\n\t\tconst doc = factory();\n\n\t\tif (!doc) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst tag = this.props.containerTagName ?? 'body';\n\t\tconst el = tag === 'body' || tag === 'fragment' ? doc.body : doc.createElement(tag);\n\n\t\tif (markup.match(INVALID_ROOTS)) {\n\t\t\tif (__DEV__) {\n\t\t\t\tthrow new Error('HTML documents as Interweave content are not supported.');\n\t\t\t}\n\t\t} else {\n\t\t\tel.innerHTML = this.convertLineBreaks(this.props.escapeHtml ? escapeHtml(markup) : markup);\n\t\t}\n\n\t\treturn el;\n\t}\n\n\t/**\n\t * Convert an elements attribute map to an object map.\n\t * Returns null if no attributes are defined.\n\t */\n\textractAttributes(node: HTMLElement): Attributes | null {\n\t\tconst { allowAttributes } = this.props;\n\t\tconst attributes: Attributes = {};\n\t\tlet count = 0;\n\n\t\tif (node.nodeType !== ELEMENT_NODE || !node.attributes) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// @ts-expect-error Cant type iterator\n\t\t[...node.attributes].forEach((attr: Attr) => {\n\t\t\tconst { name, value } = attr;\n\t\t\tconst newName = name.toLowerCase();\n\t\t\tconst filter = ATTRIBUTES[newName] || ATTRIBUTES[name];\n\n\t\t\t// Verify the node is safe from attacks\n\t\t\tif (!this.isSafe(node)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Do not allow denied attributes, excluding ARIA attributes\n\t\t\t// Do not allow events or XSS injections\n\t\t\tif (\n\t\t\t\t!newName.match(ALLOWED_ATTRS) &&\n\t\t\t\t((!allowAttributes && (!filter || filter === FILTER_DENY)) ||\n\t\t\t\t\tnewName.startsWith('on') ||\n\t\t\t\t\tvalue.replace(/(\\s|\\0|&#x0([9AD]);)/, '').match(/(javascript|vbscript|livescript|xss):/i))\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Apply attribute filters\n\t\t\tlet newValue: AttributeValue = newName === 'style' ? this.extractStyleAttribute(node) : value;\n\n\t\t\t// Cast to boolean\n\t\t\tif (filter === FILTER_CAST_BOOL) {\n\t\t\t\tnewValue = true;\n\n\t\t\t\t// Cast to number\n\t\t\t} else if (filter === FILTER_CAST_NUMBER) {\n\t\t\t\tnewValue = Number.parseFloat(String(newValue));\n\n\t\t\t\t// Cast to string\n\t\t\t} else if (filter !== FILTER_NO_CAST) {\n\t\t\t\tnewValue = String(newValue);\n\t\t\t}\n\n\t\t\tattributes[ATTRIBUTES_TO_PROPS[newName] || newName] = this.applyAttributeFilters(\n\t\t\t\tnewName as keyof ElementAttributes,\n\t\t\t\tnewValue,\n\t\t\t) as AttributeValue;\n\t\t\tcount += 1;\n\t\t});\n\n\t\tif (count === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn attributes;\n\t}\n\n\t/**\n\t * Extract the style attribute as an object and remove values that allow for attack vectors.\n\t */\n\textractStyleAttribute(node: HTMLElement): object {\n\t\tconst styles: Record<string, number | string> = {};\n\n\t\t// eslint-disable-next-line unicorn/prefer-spread\n\t\tArray.from(node.style).forEach((key) => {\n\t\t\tconst value = node.style[key as keyof CSSStyleDeclaration];\n\n\t\t\tif (typeof value === 'string' || typeof value === 'number') {\n\t\t\t\tstyles[key.replace(/-([a-z])/g, (match, letter) => String(letter).toUpperCase())] = value;\n\t\t\t}\n\t\t});\n\n\t\treturn styles;\n\t}\n\n\t/**\n\t * Return configuration for a specific tag.\n\t */\n\tgetTagConfig(tagName: string): NodeConfig {\n\t\tconst common = {\n\t\t\tchildren: [],\n\t\t\tcontent: 0,\n\t\t\tinvalid: [],\n\t\t\tparent: [],\n\t\t\tself: true,\n\t\t\ttagName: '',\n\t\t\ttype: 0,\n\t\t\tvoid: false,\n\t\t};\n\n\t\t// Only spread when a tag config exists,\n\t\t// otherwise we use the empty `tagName`\n\t\t// for parent config inheritance.\n\t\tif (TAGS[tagName]) {\n\t\t\treturn {\n\t\t\t\t...common,\n\t\t\t\t...TAGS[tagName],\n\t\t\t\ttagName,\n\t\t\t};\n\t\t}\n\n\t\treturn common;\n\t}\n\n\t/**\n\t * Verify that a node is safe from XSS and injection attacks.\n\t */\n\tisSafe(node: HTMLElement): boolean {\n\t\t// URLs should only support HTTP, email and phone numbers\n\t\tif (typeof HTMLAnchorElement !== 'undefined' && node instanceof HTMLAnchorElement) {\n\t\t\tconst href = node.getAttribute('href');\n\n\t\t\t// Fragment protocols start with about:\n\t\t\t// So let's just allow them\n\t\t\tif (href?.startsWith('#')) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tconst protocol = node.protocol.toLowerCase();\n\n\t\t\treturn (\n\t\t\t\tprotocol === ':' ||\n\t\t\t\tprotocol === 'http:' ||\n\t\t\t\tprotocol === 'https:' ||\n\t\t\t\tprotocol === 'mailto:' ||\n\t\t\t\tprotocol === 'tel:'\n\t\t\t);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Verify that an HTML tag is allowed to render.\n\t */\n\tisTagAllowed(tagName: string): boolean {\n\t\tif (this.banned.has(tagName) || this.blocked.has(tagName)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n\t\treturn this.props.allowElements || this.allowed.has(tagName);\n\t}\n\n\t/**\n\t * Parse the markup by injecting it into a detached document,\n\t * while looping over all child nodes and generating an\n\t * array to interpolate into JSX.\n\t */\n\tparse(): Node[] {\n\t\tif (!this.container) {\n\t\t\treturn [];\n\t\t}\n\n\t\treturn this.parseNode(this.container, this.getTagConfig(this.container.nodeName.toLowerCase()));\n\t}\n\n\t/**\n\t * Loop over the nodes children and generate a\n\t * list of text nodes and React elements.\n\t */\n\tparseNode(parentNode: HTMLElement, parentConfig: NodeConfig): Node[] {\n\t\tconst {\n\t\t\tnoHtml,\n\t\t\tnoHtmlExceptMatchers,\n\t\t\tallowElements,\n\t\t\ttransform,\n\t\t\ttransformOnlyAllowList,\n\t\t} = this.props;\n\t\tlet content: Node[] = [];\n\t\tlet mergedText = '';\n\n\t\t// @ts-expect-error Cant type iterator\n\t\t[...parentNode.childNodes].forEach((node: ChildNode) => {\n\t\t\t// Create React elements from HTML elements\n\t\t\tif (node.nodeType === ELEMENT_NODE) {\n\t\t\t\tconst tagName = node.nodeName.toLowerCase();\n\t\t\t\tconst config = this.getTagConfig(tagName);\n\n\t\t\t\t// Persist any previous text\n\t\t\t\tif (mergedText) {\n\t\t\t\t\tcontent.push(mergedText);\n\t\t\t\t\tmergedText = '';\n\t\t\t\t}\n\n\t\t\t\t// Apply node filters first\n\t\t\t\tconst nextNode = this.applyNodeFilters(tagName, node as HTMLElement);\n\n\t\t\t\tif (!nextNode) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Apply transformation second\n\t\t\t\tlet children;\n\n\t\t\t\tif (transform && !(transformOnlyAllowList && !this.isTagAllowed(tagName))) {\n\t\t\t\t\tthis.keyIndex += 1;\n\t\t\t\t\tconst key = this.keyIndex;\n\n\t\t\t\t\t// Must occur after key is set\n\t\t\t\t\tchildren = this.parseNode(nextNode, config);\n\n\t\t\t\t\tconst transformed = transform(nextNode, children, config);\n\n\t\t\t\t\tif (transformed === null) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof transformed !== 'undefined') {\n\t\t\t\t\t\tcontent.push(React.cloneElement(transformed as React.ReactElement<unknown>, { key }));\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Reset as we're not using the transformation\n\t\t\t\t\tthis.keyIndex = key - 1;\n\t\t\t\t}\n\n\t\t\t\t// Never allow these tags (except via a transformer)\n\t\t\t\tif (this.banned.has(tagName)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Only render when the following criteria is met:\n\t\t\t\t//  - HTML has not been disabled\n\t\t\t\t//  - Tag is allowed\n\t\t\t\t//  - Child is valid within the parent\n\t\t\t\tif (\n\t\t\t\t\t!(noHtml || (noHtmlExceptMatchers && tagName !== 'br')) &&\n\t\t\t\t\tthis.isTagAllowed(tagName) &&\n\t\t\t\t\t(allowElements || this.canRenderChild(parentConfig, config))\n\t\t\t\t) {\n\t\t\t\t\tthis.keyIndex += 1;\n\n\t\t\t\t\t// Build the props as it makes it easier to test\n\t\t\t\t\tconst attributes = this.extractAttributes(nextNode);\n\t\t\t\t\tconst elementProps: ElementProps = {\n\t\t\t\t\t\ttagName,\n\t\t\t\t\t};\n\n\t\t\t\t\tif (attributes) {\n\t\t\t\t\t\telementProps.attributes = attributes;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (config.void) {\n\t\t\t\t\t\telementProps.selfClose = config.void;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontent.push(\n\t\t\t\t\t\tReact.createElement(\n\t\t\t\t\t\t\tElement,\n\t\t\t\t\t\t\t{ ...elementProps, key: this.keyIndex },\n\t\t\t\t\t\t\tchildren ?? this.parseNode(nextNode, config),\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\n\t\t\t\t\t// Render the children of the current element only.\n\t\t\t\t\t// Important: If the current element is not allowed,\n\t\t\t\t\t// use the parent element for the next scope.\n\t\t\t\t} else {\n\t\t\t\t\tcontent = [\n\t\t\t\t\t\t...content,\n\t\t\t\t\t\t...this.parseNode(nextNode, config.tagName ? config : parentConfig),\n\t\t\t\t\t];\n\t\t\t\t}\n\n\t\t\t\t// Apply matchers if a text node\n\t\t\t} else if (node.nodeType === TEXT_NODE) {\n\t\t\t\tconst text =\n\t\t\t\t\tnoHtml && !noHtmlExceptMatchers\n\t\t\t\t\t\t? node.textContent\n\t\t\t\t\t\t: // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n\t\t\t\t\t\t  this.applyMatchers(node.textContent || '', parentConfig);\n\n\t\t\t\tif (Array.isArray(text)) {\n\t\t\t\t\tcontent = [...content, ...text];\n\t\t\t\t} else {\n\t\t\t\t\tmergedText += text!;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (mergedText) {\n\t\t\tcontent.push(mergedText);\n\t\t}\n\n\t\treturn content;\n\t}\n\n\t/**\n\t * Deconstruct the string into an array, by replacing custom tokens with React elements,\n\t * so that React can render it correctly.\n\t */\n\treplaceTokens(tokenizedString: string, elements: MatcherElementsMap): ChildrenNode {\n\t\tif (!tokenizedString.includes('{{{')) {\n\t\t\treturn tokenizedString;\n\t\t}\n\n\t\tconst nodes: Node[] = [];\n\t\tlet text = tokenizedString;\n\t\tlet open: RegExpMatchArray | null = null;\n\n\t\t// Find an open token tag\n\t\twhile ((open = text.match(OPEN_TOKEN))) {\n\t\t\tconst [match, tokenName] = open;\n\t\t\tconst startIndex = open.index!;\n\t\t\tconst isVoid = match.includes('/');\n\n\t\t\tif (__DEV__ && !elements[tokenName]) {\n\t\t\t\tthrow new Error(`Token \"${tokenName}\" found but no matching element to replace with.`);\n\t\t\t}\n\n\t\t\t// Extract the previous non-token text\n\t\t\tif (startIndex > 0) {\n\t\t\t\tnodes.push(text.slice(0, startIndex));\n\n\t\t\t\t// Reduce text so that the closing tag will be found after the opening\n\t\t\t\ttext = text.slice(startIndex);\n\t\t\t}\n\n\t\t\tconst { children, matcher, props: elementProps } = elements[tokenName];\n\t\t\tlet endIndex: number;\n\n\t\t\t// Use tag as-is if void\n\t\t\tif (isVoid) {\n\t\t\t\tendIndex = match.length;\n\n\t\t\t\tnodes.push(matcher.createElement(children, elementProps));\n\n\t\t\t\t// Find the closing tag if not void\n\t\t\t} else {\n\t\t\t\tconst close = text.match(new RegExp(`{{{/${tokenName}}}}`))!;\n\n\t\t\t\tif (__DEV__ && !close) {\n\t\t\t\t\tthrow new Error(`Closing token missing for interpolated element \"${tokenName}\".`);\n\t\t\t\t}\n\n\t\t\t\tendIndex = close.index! + close[0].length;\n\n\t\t\t\tnodes.push(\n\t\t\t\t\tmatcher.createElement(\n\t\t\t\t\t\tthis.replaceTokens(text.slice(match.length, close.index), elements),\n\t\t\t\t\t\telementProps,\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Reduce text for the next interation\n\t\t\ttext = text.slice(endIndex);\n\t\t}\n\n\t\t// Extra the remaining text\n\t\tif (text.length > 0) {\n\t\t\tnodes.push(text);\n\t\t}\n\n\t\t// Reduce to a string if possible\n\t\tif (nodes.length === 0) {\n\t\t\treturn '';\n\t\t}\n\t\tif (nodes.length === 1 && typeof nodes[0] === 'string') {\n\t\t\treturn nodes[0];\n\t\t}\n\n\t\treturn nodes;\n\t}\n}\n","/* eslint-disable react/jsx-fragments */\n\nimport React from 'react';\nimport { Element } from './Element';\nimport { Parser } from './Parser';\nimport { MarkupProps } from './types';\n\nexport function Markup(props: MarkupProps) {\n\tconst {\n\t\tattributes,\n\t\tclassName,\n\t\tcontainerTagName,\n\t\tcontent,\n\t\temptyContent,\n\t\tparsedContent,\n\t\ttagName,\n\t\tnoWrap: baseNoWrap,\n\t} = props;\n\tconst tag = containerTagName ?? tagName ?? 'span';\n\tconst noWrap = tag === 'fragment' ? true : baseNoWrap;\n\tlet mainContent;\n\n\tif (parsedContent) {\n\t\tmainContent = parsedContent;\n\t} else {\n\t\tconst markup = new Parser(content ?? '', props).parse();\n\n\t\tif (markup.length > 0) {\n\t\t\tmainContent = markup;\n\t\t}\n\t}\n\n\tif (!mainContent) {\n\t\tmainContent = emptyContent;\n\t}\n\n\tif (noWrap) {\n\t\t// eslint-disable-next-line react/jsx-no-useless-fragment\n\t\treturn <React.Fragment>{mainContent}</React.Fragment>;\n\t}\n\n\treturn (\n\t\t<Element attributes={attributes} className={className} tagName={tag}>\n\t\t\t{mainContent}\n\t\t</Element>\n\t);\n}\n","/* eslint-disable promise/prefer-await-to-callbacks */\nimport React from 'react';\nimport { Markup } from './Markup';\nimport { Parser } from './Parser';\nimport { InterweaveProps } from './types';\n\nexport function Interweave(props: InterweaveProps) {\n\tconst {\n\t\tattributes,\n\t\tclassName,\n\t\tcontent = '',\n\t\tdisableFilters = false,\n\t\tdisableMatchers = false,\n\t\temptyContent = null,\n\t\tfilters = [],\n\t\tmatchers = [],\n\t\tonAfterParse = null,\n\t\tonBeforeParse = null,\n\t\ttagName = 'span',\n\t\tnoWrap = false,\n\t\t...parserProps\n\t} = props;\n\tconst allMatchers = disableMatchers ? [] : matchers;\n\tconst allFilters = disableFilters ? [] : filters;\n\tconst beforeCallbacks = onBeforeParse ? [onBeforeParse] : [];\n\tconst afterCallbacks = onAfterParse ? [onAfterParse] : [];\n\n\t// Inherit callbacks from matchers\n\tallMatchers.forEach((matcher) => {\n\t\tif (matcher.onBeforeParse) {\n\t\t\tbeforeCallbacks.push(matcher.onBeforeParse.bind(matcher));\n\t\t}\n\n\t\tif (matcher.onAfterParse) {\n\t\t\tafterCallbacks.push(matcher.onAfterParse.bind(matcher));\n\t\t}\n\t});\n\n\t// Trigger before callbacks\n\tconst markup = beforeCallbacks.reduce((string, callback) => {\n\t\tconst nextString = callback(string, props);\n\n\t\tif (__DEV__ && typeof nextString !== 'string') {\n\t\t\tthrow new TypeError('Interweave `onBeforeParse` must return a valid HTML string.');\n\t\t}\n\n\t\treturn nextString;\n\t}, content ?? '');\n\n\t// Parse the markup\n\tconst parser = new Parser(markup, parserProps, allMatchers, allFilters);\n\n\t// Trigger after callbacks\n\tconst nodes = afterCallbacks.reduce((parserNodes, callback) => {\n\t\tconst nextNodes = callback(parserNodes, props);\n\n\t\tif (__DEV__ && !Array.isArray(nextNodes)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t'Interweave `onAfterParse` must return an array of strings and React elements.',\n\t\t\t);\n\t\t}\n\n\t\treturn nextNodes;\n\t}, parser.parse());\n\n\treturn (\n\t\t<Markup\n\t\t\tattributes={attributes}\n\t\t\tclassName={className}\n\t\t\t// eslint-disable-next-line react/destructuring-assignment\n\t\t\tcontainerTagName={props.containerTagName}\n\t\t\temptyContent={emptyContent}\n\t\t\tnoWrap={noWrap}\n\t\t\tparsedContent={nodes.length === 0 ? undefined : nodes}\n\t\t\ttagName={tagName}\n\t\t/>\n\t);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}